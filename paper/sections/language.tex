\section{Koka-mini Language}
\subsection{Syntax and semantics}
\input{figures/koka-mini-syntax}
\figref{koka-mini-IR} presents the syntax of Koka-mini intermediate language. Expressions are built from variables, constants, abstraction, application, memory location, references, dereferences, assignment, memory isolation, heap binding, let binding and conditional. The semantic uses the judgment of the form $\eval{s}{e}{s'}{v}$ representing that the evaluation of the expression $e$ in the state $s$ produces an updated state $s'$ and a value $v$.
A state is a pair of a memory $\kheap$ (mapping from location to values) and a valuation for variables $\kvm$ (mapping from variables to values). $\kvm(x)$ represents the value associated with the variable $x$ in the virtual map $\kvm$ and $\kheap[l]$ represents the value present as the location $l$ in the heap $\kheap$. The notion $[\_ \leftarrow \_]$ represents updating the memory or the virtual map. The projection $s_{\kheap}$ returns the heap and $s_{\kvm}$ returns the virtual map.

Evaluation of a variable $\kw{SVAR}$ results to the value associated with the variable $x$ in the virtual map $\Pi$ for the variable $x$. Allocation rule $\kw{SALLOC}$ represents the allocation of location $e$ (which is not yet reduced to a value). It produces the new state $s'$, which is obtained during the evaluation of expression $e$. Allocation rule $\kw{SALLOCV}$ assigns the location $l$ in the heap with the value $v$ of type $T$, with the constraint that $l$ needs to be a fresh location. $fresh(l)$ ensures that the location $l$ is never assigned or being used in the heap $\Theta$. It produces the new state $s'$ which contains the updated heap $\Theta'$ and the old virtual map $s_\Pi$. Dereferencing a location is represented using two rules $\kw{SDEREF}$ and $\kw{SDEREFV}$. $\kw{SDEREF}$ represents the evaluation of $\deref {e} {T}$ where $e$ has not reduced to a value, but takes step to $e'$. The rule $\kw{SDEREFV}$ looks for the value at location $l$ in the heap $\Theta$ and reduces to the same value without updating the state. 

The memory update is performed using the expression $\eass {e_1} {e_2}$. The operational semantics consists of three rules. The rule $\kw{SMEMU1}$ presents the scenario where the expression $e_1$ has not reduced to a location and takes further step to expression ${e_1'}$ producing the updated state $s'$. Similarly, the rule $\kw{SMEMU2}$ presents the scenario where the value to be assigned $e_2$ to location $l$ has not yet reduced to a value. The rule $\kw{SMEMUV}$ presents the operational semantics of $\eass {\addr l T} {v}$, where the location $l$ is updated with the new value $v$ and it returns the updated state. 

Evaluation of $\run {\hpe \kheap e}$ produces $e$ representing the scenario of safely removing the state effect and proceeding with the expression. This captures the essence of the function whose body can produce stateful effect, but the function itself is a total function. It is also necessary to argue that the stateful effect observed during the computation of the body of the function does not escape and leaks the state. To isolate the state effect, we also need a notion of heap-bindings in our semantics. The expression $\hpe \kheap e$ represents the heap-bindings with heap $\Theta$ and expression $e$ representing the various operations like assignment and dereferencing.
The operational semantics for function application $\app e e' n$ is pretty-straightforward with the constraint of evaluating the arguments before calling the function. The operational semantics of $\kw{let-binding}$ and conditional is straightforward.

\input{figures/expr-semantics}

\subsection{Type system}
\input{figures/koka-type-system}
\figref{koka-mini-types} presents the available types in the language. The type of the language does not only capture the type of the computations involved, but also captures the side-effect that can be produced during the computation.
\subsection{Effects}
To capture the notion of side-effects that might arise during a computation, a new type called $\kw{effect}$ is introduced. The basic effects represented as $e_l$ in the \figref{koka-mini-types} can be $\kw{exn}$, $\kw{div}$ and $\hid{\xi}$. When a function can throw an exception, it gets an $\kw{exn}$ effect. A non-terminating function gets $\kw{div}$ effect. The effect $\hid$ represents an identifier that captures the stateful effects over the heap. For example, allocation or dereferencing a pointer issues a stateful effect as it performs operation related to heap.
A function can also produce more than one effect, which is represented as row of effects $\overline{e_f}$. For example, the effect of a pure function is represented as $[\kw{exn}, \kw{div}]$. A total function does not produce any side-effect, which is represented by $\phi_{e_f}$. 

The types are made from basic and primitive types. The primitive types supported in the language are $\kw{tunit}$, $\kw{int}$ and $\kw{bool}$. The basic types are made from primitive types. The types $\kw{T}$ are made from basic types, function types, reference type and collection of types. The function type is represented as $\funt t n {\kw{e_f}} t$, where $\overline{t}$ represents the type of the arguments, n represents the number of arguments, ${\kw{e_f}}$ captures the effect and $t$ represents the return type of the function.

\input{figures/expr-typesystem}

The typing rules are stated under the typing environment $\Gamma$ and store typing environment $\Sigma$. $\Gamma$ represents the typing environment that maps variables to their types. Since our language deals with memory, we need to take into account the types associated with the memory locations. $\Sigma$ represents the store typing environment that maps locations to their types. The typing judgment is of the form $\typerule {\Gamma} {\Sigma} e T e_f$, which states that in the typing environment $\Gamma$ and store typing environment $\Sigma$, the expression $e$ has the type $T$ and effect $e_f$. The environment can be extended to add new pair of variables or locations and types. It is represented as $\Gamma, x : T$

The typing rule $\kw{VAR}$ for variable involves looking for the type of the variable $x$ in the environment $\Gamma$. The derived effect for variable is chosen as any arbitrary effect $\epsilon$ as the evaluation of the variable does not produce any side-effect. The typing rules for constants are derived in the similar manner. The typing rule $\kw{LOC}$ derives the type $\reft h T$ for the location $l$ by looking at the type associated with location $l$ in the store typing environment $\Sigma$. Whenever a location is created, it is initialised with some value of some type, which in turns determines the type of the location. The rule $\kw{ALLOC}$ presents the typing rule for allocation $\alloc e {t_b}$. It ensures that the type associated with allocation is always a basic-type $t_b$ (it avoids having a situation of pointer containing another pointer). The effect type captures the stateful effect ($\hid{h}$) and also the effect that might arise during the computation of $e$. The typing rule $\kw{DEREF}$ for dereferencing is similar to allocation; it returns basic-type to ensure that the value store at location $e$ is not a reference type. The typing rule $\kw{MEMU}$ presents the typing derivation for memory update $\eass {e_1} {e_2}$. It ensures that the type of value assigned to the location $e_1$ is of basic-type and the location $e_1$ is of reference type. The rule $\kw{RUN}$ presents the typing rule for memory isolation. As we are aware of the fact that $\run {e}$ isolates the state and makes sure that the state $h$ is not observed or modified from outside the expression. Hence the effect of expression $e$ is ${[\hid{h}; \epsilon]}$, but the result effect is only $\epsilon$. To safely eliminate the state effect, we need to ensure that $h$ is not a free variable in the context \spnote{Not sure what to write about to free variables}. The rule $\kw{HEAPB}$ presents the typing rule for heap binding. The heap binding ${\hpe \kheap e}$ get the stateful effect $[\hid{h}; \epsilon]$ and type of the expression $e$. The typing rule for let-binding and conditional expression is straight-forward.

